module [
    HamtNumBase,
    empty,
    insert,
    get,
    remove,
    map,
    walk,
    walk_until,
    to_list,
    from_list,
    is_empty,
    len,
]

## Hash Array Mapped Trie (HAMT) optimized for numeric keys.
## Uses 5 bits per level (32-way branching) with bitmap indexing for efficient memory usage.
HamtNumBase k v : [
    Empty,
    Leaf { hash : U64, key : k, value : v },
    Collision { hash : U64, entries : List (k, v) },
    Branch { bitmap : U32, children : List (HamtNumBase k v) },
]

## Bit manipulation constants
bits_per_level : U64
bits_per_level = 5

mask : U64
mask = 0x1F

## Hash a numeric key
hash_key : k -> U64 where k implements Num
hash_key = |n|
    i = Num.to_i64(n)
    u = Num.to_u64(i)
    # Mix the bits using multiplication by golden ratio
    u
    |> Num.bitwise_xor(Num.shift_right_by(u, 32u8))
    |> Num.mul_wrap(0x9e3779b97f4a7c15)

## Creates an empty HAMT.
empty : {} -> HamtNumBase k v
empty = |{}| Empty

## Checks if the HAMT is empty.
is_empty : HamtNumBase k v -> Bool
is_empty = |trie|
    when trie is
        Empty -> Bool.true
        _ -> Bool.false

## Extracts the fragment (5 bits) of the hash at the given shift level.
fragment : U64, U64 -> U64
fragment = |hash, shift|
    Num.bitwise_and(Num.shift_right_by(hash, Num.to_u8(shift)), mask)

## Converts a fragment to a bitmap position.
bitmap_pos : U64 -> U32
bitmap_pos = |frag|
    Num.shift_left_by(1u32, Num.to_u8(frag))

## Counts the number of set bits in the bitmap before the given position.
sparse_index : U32, U32 -> U64
sparse_index = |bitmap, bit|
    masked = Num.bitwise_and(bitmap, Num.sub_saturated(bit, 1))
    Num.to_u64(pop_count(masked))

## Counts the number of set bits in a U32 (population count).
pop_count : U32 -> U8
pop_count = |n|
    Num.count_one_bits(n)

## Inserts an element into a list at the specified index.
list_insert_at : List a, U64, a -> List a
list_insert_at = |list, idx, elem|
    before = List.take_first(list, idx)
    after = List.drop_first(list, idx)
    before |> List.append(elem) |> List.concat(after)

## Inserts a key-value pair into the HAMT.
insert : k, v, HamtNumBase k v -> HamtNumBase k v where k implements Num
insert = |key, value, trie|
    hash_val = hash_key(key)
    insert_helper(0, hash_val, key, value, trie)

insert_helper : U64, U64, k, v, HamtNumBase k v -> HamtNumBase k v where k implements Num
insert_helper = |shift, hash, key, value, trie|
    when trie is
        Empty ->
            Leaf { hash, key, value }

        Leaf({ hash: leaf_hash, key: leaf_key, value: leaf_value }) ->
            if hash == leaf_hash then
                if key == leaf_key then
                    Leaf { hash, key, value }
                else
                    Collision { hash, entries: [(leaf_key, leaf_value), (key, value)] }
            else
                frag = fragment(hash, shift)
                leaf_frag = fragment(leaf_hash, shift)

                if frag == leaf_frag then
                    child = insert_helper(shift + bits_per_level, hash, key, value, trie)
                    bit = bitmap_pos(frag)
                    Branch { bitmap: bit, children: [child] }
                else
                    bit = bitmap_pos(frag)
                    leaf_bit = bitmap_pos(leaf_frag)
                    new_leaf = Leaf { hash, key, value }

                    if frag < leaf_frag then
                        Branch { bitmap: Num.bitwise_or(bit, leaf_bit), children: [new_leaf, trie] }
                    else
                        Branch { bitmap: Num.bitwise_or(bit, leaf_bit), children: [trie, new_leaf] }

        Collision({ hash: coll_hash, entries }) ->
            if hash == coll_hash then
                updated_entries = update_collision_entries(entries, key, value)
                Collision { hash: coll_hash, entries: updated_entries }
            else
                frag = fragment(hash, shift)
                coll_frag = fragment(coll_hash, shift)

                if frag == coll_frag then
                    child = insert_helper(shift + bits_per_level, hash, key, value, trie)
                    bit = bitmap_pos(frag)
                    Branch { bitmap: bit, children: [child] }
                else
                    bit = bitmap_pos(frag)
                    coll_bit = bitmap_pos(coll_frag)
                    new_leaf = Leaf { hash, key, value }

                    if frag < coll_frag then
                        Branch { bitmap: Num.bitwise_or(bit, coll_bit), children: [new_leaf, trie] }
                    else
                        Branch { bitmap: Num.bitwise_or(bit, coll_bit), children: [trie, new_leaf] }

        Branch({ bitmap, children }) ->
            frag = fragment(hash, shift)
            bit = bitmap_pos(frag)

            if Num.bitwise_and(bitmap, bit) != 0 then
                idx = sparse_index(bitmap, bit)
                when List.get(children, idx) is
                    Ok(child) ->
                        updated_child = insert_helper(shift + bits_per_level, hash, key, value, child)
                        updated_children = List.set(children, idx, updated_child)
                        Branch { bitmap, children: updated_children }

                    Err(OutOfBounds) ->
                        trie
            else
                idx = sparse_index(bitmap, bit)
                new_child = Leaf { hash, key, value }
                updated_children = list_insert_at(children, idx, new_child)
                updated_bitmap = Num.bitwise_or(bitmap, bit)
                Branch { bitmap: updated_bitmap, children: updated_children }

update_collision_entries : List (k, v), k, v -> List (k, v) where k implements Num
update_collision_entries = |entries, key, value|
    updated =
        List.map(
            entries,
            |entry|
                when entry is
                    (k, _) if k == key -> (key, value)
                    _ -> entry,
        )

    found = List.any(entries, |(k, _)| k == key)

    if found then
        updated
    else
        List.append(entries, (key, value))

## Retrieves the value associated with a key.
get : HamtNumBase k v, k -> Result v {} where k implements Num
get = |trie, key|
    hash_val = hash_key(key)
    get_helper(0, hash_val, key, trie)

get_helper : U64, U64, k, HamtNumBase k v -> Result v {} where k implements Num
get_helper = |shift, hash, key, trie|
    when trie is
        Empty ->
            Err {}

        Leaf({ hash: leaf_hash, key: leaf_key, value }) ->
            if hash == leaf_hash && key == leaf_key then
                Ok(value)
            else
                Err {}

        Collision({ hash: coll_hash, entries }) ->
            if hash == coll_hash then
                find_in_collision(entries, key)
            else
                Err {}

        Branch({ bitmap, children }) ->
            frag = fragment(hash, shift)
            bit = bitmap_pos(frag)

            if Num.bitwise_and(bitmap, bit) != 0 then
                idx = sparse_index(bitmap, bit)
                when List.get(children, idx) is
                    Ok(child) ->
                        get_helper(shift + bits_per_level, hash, key, child)

                    Err(OutOfBounds) ->
                        Err {}
            else
                Err {}

find_in_collision : List (k, v), k -> Result v {} where k implements Num
find_in_collision = |entries, key|
    List.walk_until(
        entries,
        Err {},
        |_, (k, v)|
            if k == key then
                Break(Ok(v))
            else
                Continue(Err {}),
    )

## Removes a key-value pair from the HAMT.
remove : HamtNumBase k v, k -> HamtNumBase k v where k implements Num
remove = |trie, key|
    hash_val = hash_key(key)
    when remove_helper(0, hash_val, key, trie) is
        Ok(new_trie) -> new_trie
        Err {} -> trie

remove_helper : U64, U64, k, HamtNumBase k v -> Result (HamtNumBase k v) {} where k implements Num
remove_helper = |shift, hash, key, trie|
    when trie is
        Empty ->
            Err {}

        Leaf({ hash: leaf_hash, key: leaf_key }) ->
            if hash == leaf_hash && key == leaf_key then
                Ok(Empty)
            else
                Err {}

        Collision({ hash: coll_hash, entries }) ->
            if hash == coll_hash then
                filtered = List.drop_if(entries, |(k, _)| k == key)
                when List.len(filtered) is
                    0 -> Ok(Empty)
                    1 ->
                        when List.first(filtered) is
                            Ok((k, v)) -> Ok(Leaf { hash: coll_hash, key: k, value: v })
                            Err(ListWasEmpty) -> Err {}

                    _ -> Ok(Collision { hash: coll_hash, entries: filtered })
            else
                Err {}

        Branch({ bitmap, children }) ->
            frag = fragment(hash, shift)
            bit = bitmap_pos(frag)

            if Num.bitwise_and(bitmap, bit) != 0 then
                idx = sparse_index(bitmap, bit)
                when List.get(children, idx) is
                    Ok(child) ->
                        when remove_helper(shift + bits_per_level, hash, key, child) is
                            Ok(Empty) ->
                                updated_children = List.drop_at(children, idx)
                                updated_bitmap = Num.bitwise_xor(bitmap, bit)

                                when List.len(updated_children) is
                                    0 -> Ok(Empty)
                                    1 ->
                                        when List.first(updated_children) is
                                            Ok(only_child) -> Ok(only_child)
                                            Err(ListWasEmpty) -> Ok(Empty)

                                    _ -> Ok(Branch { bitmap: updated_bitmap, children: updated_children })

                            Ok(updated_child) ->
                                updated_children = List.set(children, idx, updated_child)
                                Ok(Branch { bitmap, children: updated_children })

                            Err {} ->
                                Err {}

                    Err(OutOfBounds) ->
                        Err {}
            else
                Err {}

## Transforms all values in the HAMT using the given function.
map : HamtNumBase k v, (v -> w) -> HamtNumBase k w
map = |trie, fn|
    when trie is
        Empty -> Empty
        Leaf({ hash, key, value }) ->
            Leaf { hash, key, value: fn(value) }

        Collision({ hash, entries }) ->
            mapped_entries = List.map(entries, |(k, v)| (k, fn(v)))
            Collision { hash, entries: mapped_entries }

        Branch({ bitmap, children }) ->
            mapped_children = List.map(children, |child| map(child, fn))
            Branch { bitmap, children: mapped_children }

## Iterates over all key-value pairs in the HAMT, accumulating a state.
walk : HamtNumBase k v, state, (state, k, v -> state) -> state
walk = |trie, initial_state, fn|
    when trie is
        Empty -> initial_state
        Leaf({ key, value }) ->
            fn(initial_state, key, value)

        Collision({ entries }) ->
            List.walk(entries, initial_state, |state, (k, v)| fn(state, k, v))

        Branch({ children }) ->
            List.walk(children, initial_state, |state, child| walk(child, state, fn))

## Iterates over all key-value pairs with early termination support.
walk_until : HamtNumBase k v, state, (state, k, v -> [Continue state, Break state]) -> state
walk_until = |trie, initial_state, fn|
    when trie is
        Empty -> initial_state
        Leaf({ key, value }) ->
            when fn(initial_state, key, value) is
                Continue(s) -> s
                Break(s) -> s

        Collision({ entries }) ->
            List.walk_until(entries, initial_state, |state, (k, v)| fn(state, k, v))

        Branch({ children }) ->
            List.walk_until(
                children,
                initial_state,
                |state, child|
                    result = walk_until(child, state, fn)
                    Continue(result),
            )

## Converts the HAMT to a list of key-value pairs.
to_list : HamtNumBase k v -> List (k, v)
to_list = |trie|
    walk(trie, [], |acc, k, v| List.append(acc, (k, v)))

## Creates a HAMT from a list of key-value pairs.
from_list : List (k, v) -> HamtNumBase k v where k implements Num
from_list = |list|
    List.walk(list, Empty, |trie, (k, v)| insert(k, v, trie))

## Returns the number of key-value pairs in the HAMT.
len : HamtNumBase k v -> U64
len = |trie|
    walk(trie, 0, |count, _, _| count + 1)
